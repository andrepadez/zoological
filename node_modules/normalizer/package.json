{
  "name": "normalizer",
  "version": "1.3.0",
  "description": "Better string filter and sort for MongoDB and Mongoose Models, accounting for special (accentuated and such) utf8 characters",
  "main": "index.js",
  "scripts": {
    "test": "nodeunit tests/test.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:andrepadez/normalizer.git"
  },
  "keywords": [
    "utf8",
    "string",
    "search",
    "mongodb",
    "mongoose"
  ],
  "author": {
    "name": "André Alçada Padez",
    "email": "andre.padez@gmail.com",
    "url": "http://andrepadez.com"
  },
  "license": "MIT",
  "readme": "Normalizer\n========\n\nSimple string normalizer to use with Mongoose models or directly with Mongo; helps with filtering and sorting strings with non-english UTF8 characters.   \nI have built it to fit my current needs for the project i'm working on;   \nthis is an open invitation for you to fork it and adapt it to your needs or contribute to make it more general-purpose;\nFirst contribution i need, is to complete the charMap object with the characters i left out.\n\n<h3>you should use it because:</h3>\n<ul>\n    <li>Designed for Mongoose, but works just as easily with MongoDB</li>\n    <li>Not a Plugin!!!</li>\n    <li>Simple to use</li>\n    <li>Little or no overhead</li>\n    <li>4 methods to rule them all</li>\n    <li>All methods run synchronously</li>\n    <li>uses node-unit for testing</li>\n</ul>\n\n<h3>you should look away if:</h3>\n<ul>\n    <li>you already work with a plugin that solves your problem well</li>\n    <li>you are working with big data - this uses RegExp engine, can clog your queries</li>\n    <li>potato</li>\n</ul>\n\nUsage\n-----\n\nAs always you have to require it:\n\n    var normalizer = require('normalizer');\n\nYou can use it directly to normalize a string:\n\n    var originalString = 'André Alçada Padez';\n    var normalizedString = normalizer.normalize(originalString);\n    //normalizedString => 'andre alcada padez'\n    \nHere is an example insert:\n\n    var doc = req.body;\n    doc = normalizer.normalizeSearchFields(doc, Person);\n    var person = new Person(doc);\n    person.save();\n\nUsing with Mongo:\n\n    //you just have to pass an object, containing the fields to be normalized:\n    var schema = {\n        normalized: {\n            name: String,\n            ....\n        }\n    };\n    var doc = req.body;\n    doc = normalizer.normalizeSearchFields(doc, schema);\n    var person = new Person(doc);\n    person.save();\n    \nand for filtering and sorting:\n    \n    var filter = {nome: 'André'};\n    normalizer.treatFilter(filter);\n    var sort = {nome: 1};\n    normalizer.treatSort(sort);\n    Person.find(filter).sort(sort).exec(function(err, people){....});\n    //you can expect the correct results here\n\n\nDetailed Instructions\n-----\n<br>\n<b>Installation</b>\n    \n    npm install normalizer\nand, wherever you need it\n    \n    var normalizer = require('normalizer');\n\n<br>\n<b>Implementation</b>\n\nFirst, you need to \"pimp\" your Model's Schema, create a top-level property called normalized, containing the properties you want to normalize:\n\nand for filtering and sorting:\n    \n   \n    var schema = {\n        name: String,\n        address: {\n            city: String,\n            county: String,\n            localAddress: {\n                streetName: String,\n                building: String,\n                apartment: String\n            }\n        },\n        email: String,\n        phone: String,\n        normalized: {\n            name: String, \n            address: {\n                city: String,\n                county: String,\n                localAddress: {\n                    streetName: String,\n                }\n            }\n        }\n    };\n    \n    var schema = new mongoose.Schema(exports.schema);\n    var Person = mongoose.model('Person', schema);\n\nRight before upserting the document to the DB, you need to run normalizeSearchFields(), for example:\n    \n    var doc = req.body;\n    normalizer.normalizeSearchFields(doc, Person);\n    doc.save(function(){...});\n\n\nThat's it!, the result will be a Person instance, with the added <code>normalized</code> field, containing the transformation you would expect from the original document:\n\n    //this:\n    {\n        name: 'André Alçada',\n        address: {\n            city: 'Olhão',\n            county: 'Algés',\n            localAddress: {\n                streetName: 'Calçada de São Julião',\n                building: '13',\n                apartment: 'A'\n            }\n        },\n        email: 'andre.padez@gmail.com',\n        phone: 912345678,\n    };\n    //becomes:\n    var body = {\n        name: 'André Alçada',\n        address: {\n            city: 'Olhão',\n            county: 'Algés',\n            localAddress: {\n                streetName: 'Calçada de São Julião',\n                building: '13',\n                apartment: 'A'\n            }\n        },\n        email: 'andre.padez@gmail.com',\n        phone: 912345678,\n        normalized: {\n            name: 'andre alcada',\n            address: {\n                city: 'olhao',\n                county: 'alges',\n                localAddress: {\n                    streetName: 'calcada de sao juliao' \n                }\n            } \n        }\n    };\n\nBe careful for every time you run <code>normalizeSearchFields</code>, the normalized object is always rewritten so, you have to pass at least all the original fields that will be expected or you will lose the other ones. (side note: this is a question opened for discussion, if i get enough feedback, i will rewrite it to protect the fields).\n\n\nAPI\n-----\n<br>\n<code>normalizer.normalize()</code>\n\n    exports.normalize(String string[, Boolean keepCase]){\n        //if keepCase == false -> returned string will be lowercased \n        return String\n    }\n    \n    var string = 'André Alçada Padez'; \n    var normString = normalizer.normalize(string);\n    //normString = 'andre alcada padez';\n    //or\n    var normString = normalizer.normalize(string, true);\n    //normString = 'Andre Alcada Padez';\n<br>\n<code>normalizer.normalizeSearchFields()</code>\n\n    exports.normalizeSearchFields = function(Object doc, Mongoose.Model|Object model[, Boolean keepCase]){\n        //does not return, only updates the doc object\n    }\n    \n    var doc = req.body;\n    normalizer.normalizeSearchFields(doc, Person);\n    var person = new Person(doc);\n    person.save();\n    //see normalizer.normalize for keepCase\n    \n<br>\n<code>normalizer.normalizeFilter()</code>\n\n    exports.normalizeFilter = function(Object filter, Mongoose.Model|Object model[, Boolean wholeString][, Boolean keepCase){\n        //returns normalized filter object\n        //if wholeString == false -> a regExp is used ( /text/i ), ideal for fuzzy search or 'like' functionality \n    }\n    \n    var filter = {name: 'André', email: 'andre'};\n    filter = normalize.normalizeFilter(filter, Person); filter => {'normalized.name': 'andre', email: 'andre'}\n    //or, using keepCase:\n    filter = normalize.normalizeFilter(filter, Person, true); filter => {'normalized.name': 'Andre', email: 'andre'}\n<br>\n<code>normalizer.normalizeSort()</code>\n\n    exports.normalizeSort = function(Object sort, Mongoose.Model|Object model[, Boolean wholeString]){\n        //returns normalized sort object\n    }\n    \n    var sort = {name: 1, email: -1};\n    sort = normalize.normalizeSort(sort); // sort => {'normalized.name': 1, email: -1}\n\nRoad Map\n-----\n\n<ul>\n    <li>add more characters to the charMap - that will be up to you (: </li>\n</ul>\n\nFeel free to use, fork and please contribute reporting bugs and with pull requests\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/andrepadez/normalizer/issues"
  },
  "_id": "normalizer@1.3.0",
  "_from": "normalizer@*"
}
